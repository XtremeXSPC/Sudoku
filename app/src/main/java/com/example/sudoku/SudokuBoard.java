package com.example.sudoku;

import android.os.Parcel;
import android.os.Parcelable;
import androidx.annotation.NonNull;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.Stack;

/**
 * Represents the state and logic of a Sudoku board.
 * This class manages puzzle generation, move validation, cell states,
 * and the history of moves for the undo functionality.
 * This is the Java translation of the original Kotlin class.
 */
public class SudokuBoard implements Parcelable {

    /**
     * Enum for Sudoku difficulty levels.
     * It determines how many numbers are removed from a fully solved grid.
     */
    public enum Difficulty {
        EASY(35),
        MEDIUM(45),
        HARD(55);

        public final int cellsToRemove;

        Difficulty(int cellsToRemove) {
            this.cellsToRemove = cellsToRemove;
        }
    }

    /**
     * A private static nested class to represent a single move made by the user.
     * Used for the move history stack. Making it static means it doesn't hold
     * an implicit reference to the outer SudokuBoard instance.
     */
    private static class MoveRecord {
        final int row;
        final int col;
        final int oldValue;
        final int newValue;

        MoveRecord(int row, int col, int oldValue, int newValue) {
            this.row = row;
            this.col = col;
            this.oldValue = oldValue;
            this.newValue = newValue;
        }
    }

    private Difficulty currentDifficulty;
    // The complete solution grid, generated at the start.
    // Used to check the correctness of user moves.
    private int[][] solutionBoard;

    // The game grid visible to the user, composed of SudokuCell objects.
    private SudokuCell[][] board;

    // Stack to track moves for the undo feature.
    private final Stack<MoveRecord> movesHistory;

    private final Random random = new Random();

    /**
     * Default constructor. Initializes the board structures.
     * The puzzle itself must be generated by calling generateNewPuzzle().
     */
    public SudokuBoard() {
        this.currentDifficulty = Difficulty.MEDIUM;
        // In Java, we must explicitly initialize the arrays.
        this.solutionBoard = new int[9][9];
        this.board = new SudokuCell[9][9];
        // It's crucial to also initialize each SudokuCell object in the grid.
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                this.board[r][c] = new SudokuCell();
            }
        }
        this.movesHistory = new Stack<>();
    }


    /**
     * Generates a new Sudoku puzzle with the specified difficulty.
     * @param difficulty The difficulty level for the new puzzle.
     */
    public void generateNewPuzzle(Difficulty difficulty) {
        this.currentDifficulty = difficulty;
        this.movesHistory.clear();
        clearLogicalBoard();

        // This will fill the solutionBoard with a valid, complete Sudoku grid.
        fillBoardRecursive(0, 0);

        // Copy the solution to the user-facing board.
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                board[r][c] = new SudokuCell(solutionBoard[r][c], false, true, null);
            }
        }

        removeNumbersForPuzzle(difficulty.cellsToRemove);

        // Mark the remaining numbers as fixed.
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                if (board[r][c].getValue() != 0) {
                    board[r][c].setFixed(true);
                }
            }
        }
    }


    /**
     * Retrieves the cell at the specified row and column.
     * @param row The row (0-8).
     * @param col The column (0-8).
     * @return The SudokuCell at that position, or null if coordinates are out of bounds.
     */
    public SudokuCell getCell(int row, int col) {
        if (isValidCoordinate(row, col)) {
            return board[row][col];
        }
        return null;
    }

    /**
     * Sets the value of a cell and records the move.
     * The correctness of the input value is checked against the complete solution.
     * @param row The row (0-8).
     * @param col The column (0-8).
     * @param value The value (1-9) to insert. If 0, the cell is cleared.
     * @return `true` if the value was set (cell not fixed, valid coordinates), `false` otherwise.
     */
    public boolean setCellValue(int row, int col, int value) {
        if (!isValidCoordinate(row, col) || board[row][col].isFixed() || value < 0 || value > 9) {
            return false;
        }

        SudokuCell cell = board[row][col];
        int oldValue = cell.getValue();

        if (oldValue == value) return true;

        cell.setValue(value);
        if (value != 0) {
            cell.setCorrect(value == solutionBoard[row][col]);
        } else {
            cell.setCorrect(true); // An empty cell is not considered "incorrect".
        }

        movesHistory.push(new MoveRecord(row, col, oldValue, value));
        return true;
    }

    /**
     * Undoes the last move made.
     * Restores the previous value of the modified cell.
     * @return `true` if a move was undone, `false` if there are no moves to undo.
     */
    public boolean undoMove() {
        if (!movesHistory.isEmpty()) {
            MoveRecord lastMove = movesHistory.pop();
            SudokuCell cell = board[lastMove.row][lastMove.col];
            cell.setValue(lastMove.oldValue);
            if (cell.getValue() != 0) {
                cell.setCorrect(cell.getValue() == solutionBoard[lastMove.row][lastMove.col]);
            } else {
                cell.setCorrect(true);
            }
            return true;
        }
        return false;
    }

    /**
     * Checks if the entire board is filled with numbers.
     * @return `true` if no cell has a value of 0, `false` otherwise.
     */
    public boolean isBoardFull() {
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                if (board[r][c].getValue() == 0) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Counts the number of incorrect user-entered values on the board.
     * @return The total count of errors.
     */
    public int countUserErrors() {
        int errors = 0;
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                SudokuCell cell = board[r][c];
                if (!cell.isFixed() && cell.getValue() != 0 && !cell.isCorrect()) {
                    errors++;
                }
            }
        }
        return errors;
    }

    public Difficulty getCurrentDifficulty() {
        return currentDifficulty;
    }

    /* --- Private Helper Methods --- */

    /**
     * Resets the logical boards to an empty state.
     */
    private void clearLogicalBoard() {
        solutionBoard = new int[9][9]; // Re-initialize array (all values default to 0)
        board = new SudokuCell[9][9];
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                board[r][c] = new SudokuCell();
            }
        }
    }

    /**
     * Recursive backtracking algorithm to fill the solutionBoard.
     * @param row The current row to process.
     * @param col The current column to process.
     * @return `true` if the board was successfully filled, `false` otherwise.
     */
    private boolean fillBoardRecursive(int row, int col) {
        int currentRow = row;
        int currentCol = col;

        if (currentCol == 9) {
            currentRow++;
            currentCol = 0;
            if (currentRow == 9) {
                return true; // Board is successfully filled
            }
        }

        // Create a shuffled list of numbers to try, for randomness.
        List<Integer> numbers = new ArrayList<>();
        for (int i = 1; i <= 9; i++) { numbers.add(i); }
        Collections.shuffle(numbers, random);

        for (int num : numbers) {
            if (isSafe(solutionBoard, currentRow, currentCol, num)) {
                solutionBoard[currentRow][currentCol] = num;
                if (fillBoardRecursive(currentRow, currentCol + 1)) {
                    return true;
                }
                // Backtrack
                solutionBoard[currentRow][currentCol] = 0;
            }
        }
        return false;
    }

    /**
     * Removes a specified number of cells from the board to create the puzzle,
     * ensuring that the puzzle still has a unique solution.
     * @param cellsToRemove The number of cells to make empty.
     */
    private void removeNumbersForPuzzle(int cellsToRemove) {
        int count = cellsToRemove;
        while (count > 0) {
            int r = random.nextInt(9);
            int c = random.nextInt(9);

            if (board[r][c].getValue() != 0) {
                int tempVal = board[r][c].getValue();
                board[r][c].setValue(0);

                // Create a temporary board copy to pass to the solver.
                int[][] tempBoardForSolver = new int[9][9];
                for(int rowIdx = 0; rowIdx < 9; rowIdx++) {
                    for(int colIdx = 0; colIdx < 9; colIdx++) {
                        tempBoardForSolver[rowIdx][colIdx] = board[rowIdx][colIdx].getValue();
                    }
                }

                // If removing the number results in more than one solution, revert it.
                if (countUniqueSolutions(tempBoardForSolver, 0) != 1) {
                    board[r][c].setValue(tempVal);
                } else {
                    count--;
                }
            }
        }
    }

    /**
     * Recursively counts the number of possible solutions for a given grid state.
     * Stops and returns immediately if more than one solution is found.
     * @param currentGrid The current state of the board as a 2D int array.
     * @param count The current count of solutions found.
     * @return The number of solutions (0, 1, or 2 if more than one).
     */
    private int countUniqueSolutions(int[][] currentGrid, int count) {
        int solutionCount = count;
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                if (currentGrid[r][c] == 0) {
                    for (int num = 1; num <= 9; num++) {
                        if (isSafe(currentGrid, r, c, num)) {
                            currentGrid[r][c] = num;
                            solutionCount = countUniqueSolutions(currentGrid, solutionCount);
                            // Optimization: if we already found more than 1 solution, stop searching.
                            if (solutionCount > 1) return solutionCount;
                            // Backtrack
                            currentGrid[r][c] = 0;
                        }
                    }
                    return solutionCount;
                }
            }
        }
        return solutionCount + 1; // A full traversal means one complete solution was found.
    }

    /**
     * Checks if placing a number in a given cell is valid according to Sudoku rules.
     * @param targetBoard The board to check against.
     * @param row The row of the cell.
     * @param col The column of the cell.
     * @param num The number to check.
     * @return `true` if the placement is safe, `false` otherwise.
     */
    private boolean isSafe(int[][] targetBoard, int row, int col, int num) {
        // Check row
        for (int cIdx = 0; cIdx < 9; cIdx++) {
            if (targetBoard[row][cIdx] == num) return false;
        }
        // Check column
        for (int rIdx = 0; rIdx < 9; rIdx++) {
            if (targetBoard[rIdx][col] == num) return false;
        }
        // Check 3x3 subgrid
        int startRow = row - row % 3;
        int startCol = col - col % 3;
        for (int rOffset = 0; rOffset < 3; rOffset++) {
            for (int cOffset = 0; cOffset < 3; cOffset++) {
                if (targetBoard[startRow + rOffset][startCol + cOffset] == num) return false;
            }
        }
        return true;
    }

    /**
     * Checks if the given coordinates are within the 9x9 grid.
     */
    private boolean isValidCoordinate(int row, int col) {
        return row >= 0 && row < 9 && col >= 0 && col < 9;
    }


    /* --- Parcelable Implementation --- */

    protected SudokuBoard(Parcel in) {
        currentDifficulty = Difficulty.valueOf(in.readString());
        solutionBoard = new int[9][9];
        for (int i = 0; i < 9; i++) {
            in.readIntArray(solutionBoard[i]);
        }

        board = new SudokuCell[9][9];
        for (int i = 0; i < 9; i++) {
            // Reading an array of Parcelable objects.
            SudokuCell[] row = in.createTypedArray(SudokuCell.CREATOR);
            if (row != null) {
                board[i] = row;
            }
        }

        movesHistory = new Stack<>();
        int historySize = in.readInt();
        for (int i = 0; i < historySize; i++) {
            movesHistory.push(new MoveRecord(
                    in.readInt(),
                    in.readInt(),
                    in.readInt(),
                    in.readInt()
            ));
        }
    }

    public static final Creator<SudokuBoard> CREATOR = new Creator<SudokuBoard>() {
        @Override
        public SudokuBoard createFromParcel(Parcel in) {
            return new SudokuBoard(in);
        }

        @Override
        public SudokuBoard[] newArray(int size) {
            return new SudokuBoard[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(@NonNull Parcel dest, int flags) {
        dest.writeString(currentDifficulty.name());

        for (int i = 0; i < 9; i++) {
            dest.writeIntArray(solutionBoard[i]);
        }

        for (int i = 0; i < 9; i++) {
            dest.writeTypedArray(board[i], flags);
        }

        dest.writeInt(movesHistory.size());
        for (MoveRecord move : movesHistory) {
            dest.writeInt(move.row);
            dest.writeInt(move.col);
            dest.writeInt(move.oldValue);
            dest.writeInt(move.newValue);
        }
    }
}